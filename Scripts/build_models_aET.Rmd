---
title: "build_models_aET"
author: "Carrie Hashimoto"
date: "2024-07-29"
output: html_document
pdf-engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, warning = FALSE, message = FALSE}
packages <- c('tidyverse','mgcv','akima','readr','data.table','vroom',
              'foreach','doParallel','readr','caret','leaps','parallel','leaps',
              'viridis')

# Identify missing (not installed) packages
new.packages <-  packages[!(packages %in% installed.packages()[,"Package"])]

# Install new (not installed) packages
if(length(new.packages)) install.packages(new.packages, repos='http://cran.rstudio.com/') else print('All required packages are installed.')

invisible(lapply(packages, library, character.only = TRUE))
```

```{r}
wd <- rprojroot::find_rstudio_root_file()
outDir <- file.path(wd, "Data", fsep="/")
suppressWarnings(dir.create(outDir)) 

num_cores <- detectCores() - 1
cl <- makeCluster(num_cores - 1)  # Use one less core than available
registerDoParallel(cl)
```

```{r}
df_final <- vroom::vroom("intermediate_results.csv")
df_final$rET <- df_final$aET / df_final$prefire_ET * 100

# remove rows with NAs - all in aspect - why?
df_clean <- na.omit(df_final)

# ## 75% of the sample size
# smp_size <- floor(0.75 * nrow(df_clean))
# 
# ## set the seed to make your partition reproducible
# set.seed(123)
# train_ind <- sample(seq_len(nrow(df_final)), size = smp_size)
# 
# train <- df_final[train_ind, ]
# test <- df_final[-train_ind, ]

# explore relationships before building model
# ggplot(df_clean, aes(x = temp, y = aET)) +
#   geom_point() +
#   geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
#   labs(title = "aET vs. Temperature (GAM)")

# ggplot(df_clean, aes(x = elev, y = aET)) +
#   geom_point() +
#   geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
#   labs(title = "aET vs. Elevation (GAM)")

# fit linear models
lm_aET <- lm(aET ~ ., data = df_clean)

summary(lm_aET)

# look at residuals plots
# takes a while
#plot(lm_aET)


```

```{r}
# do cross-validation so that estimates of test error are legitimate

set.seed(0)

k <- 10
n <- nrow(df_clean)

folds <- sample(rep(1:k, length = n))

cv.errors <- matrix(NA, k, 10,
                    dimnames = list(NULL, paste(1:10)))

# define a prediction function
predict.regsubsets <- function(object, newdata, id, ...) {
  form <- as.formula(object$call [[2]])
  mat <- model.matrix(form, newdata)
  coefi <- coef(object, id = id)
  xvars <- names(coefi)
  mat[, xvars] %*% coefi
  }

for (j in 1:k) {
  best.fit <- regsubsets(aET ~ lat + lon + dNDVI + dNBR +
                           temp + precip + elev + aspect +
                           slope + soil_moisture,
                         data = df_clean[folds != j, ],
                         nvmax = 10)
  for (i in 1:10) {
    pred <- predict(best.fit, df_clean[folds == j, ], id = i)
    cv.errors[j, i] <- 
      mean((df_clean$aET[folds == j] - pred)^2)
  }
}
```

```{r}
# result: 10x10 matrix where [j,i]th element is test MSE for the jth CV fold for the best i-variable model
cv.errors

mean.cv.errors <- apply(cv.errors, 2, mean)
mean.cv.errors

# plot that shit
par(mfrow = c(1,1))
plot(mean.cv.errors, type="b")
```

```{r}
# Ok, so 4 vars is good
# make the model using all the data then

# try best subset selection

regfit.full <- regsubsets(aET ~ lat + lon + dNDVI + dNBR + temp + precip + elev + aspect + slope + soil_moisture, df_clean, nvmax = 10)

reg.summary <- summary(regfit.full)

reg.summary
# looks like dNBR is the best predictor
# dNBR and soil moisture and elev are good together

# Plot rss, adjr2
par(mfrow = c(2, 2))

plot(reg.summary$rss, xlab = "Number of Variables", ylab = "RSS",type="l")
# no point in plotting best RSS since it'll just get smaller as the model grows

# plot adjr2 for each best subset
plot(reg.summary$adjr2, xlab = "Number of Variables", ylab = "Adjusted RSq",type="l")
points(which.max(reg.summary$adjr2), reg.summary$adjr2[which.max(reg.summary$adjr2)], col = "red",cex=2, pch = 20)

# plot cp for each best subset
plot(reg.summary$cp, xlab = "Number of Variables", ylab = "Cp",type="l")
points(which.min(reg.summary$cp), reg.summary$cp[which.min(reg.summary$cp)], col = "red",cex=2, pch = 20)

# plot BIC for each best subset
plot(reg.summary$bic, xlab = "Number of Variables", ylab = "BIC",type="l")
points(which.min(reg.summary$bic), reg.summary$bic[which.min(reg.summary$bic)], col = "red",cex=2, pch = 20)

# model selection based on each criterion

plot(regfit.full, scale = "r2")
plot(regfit.full, scale = "adjr2")
plot(regfit.full, scale = "Cp")
plot(regfit.full, scale = "bic")

# take a look at the model I like the best
coef(regfit.full, 4)

# make the 4-variable model and look at the results
lm_aET_4 <- lm(aET ~ lat + lon + dNBR + elev, data = df_clean)

# Save the model to a file
save(lm_aET_4, file = "lm_aET_4.RData")


```

```{r}

# get some colors to use from viridis
viridis_colors <- viridis_pal()(10) 
pred_color <- viridis_colors[5] 

# try some other plotting strategies

set.seed(0)
sample_indices <- sample(1:nrow(df_clean), 10000)
df_sample <- df_clean[sample_indices,]

pred_sample <- predict(lm_aET_4, newdata = df_sample)
par(mfrow = c(2, 2))
# Plot with subsampled data
ggplot() +
  geom_point(data=df_sample, aes(x=dNBR, y=aET)) +
  geom_point(data=cbind(df_sample, pred_sample), aes(x=dNBR, y=pred_sample), col=pred_color) +
  theme_bw() +
  labs(title="aET vs dNBR", x="dNBR", y="aET (mm/month)")

ggplot() +
  geom_point(data=df_sample, aes(x=lat, y=aET)) +
  geom_point(data=cbind(df_sample, pred_sample), aes(x=lat, y=pred_sample), col=pred_color) +
  theme_bw() +
  labs(title="aET vs Latitude", x="Latitude", y="aET (mm/month)")

ggplot() +
  geom_point(data=df_sample, aes(x=lon, y=aET)) +
  geom_point(data=cbind(df_sample, pred_sample), aes(x=lon, y=pred_sample), col=pred_color) +
  theme_bw() +
  labs(title="aET vs Longitude", x="Longitude", y="aET (mm/month)")

ggplot() +
  geom_point(data=df_sample, aes(x=elev, y=aET)) +
  geom_point(data=cbind(df_sample, pred_sample), aes(x=elev, y=pred_sample), col=pred_color) +
  theme_bw() +
  labs(title="aET vs Elevation", x="Elevation (m)", y="aET (mm/month)")

# # alpha blending
# ggplot(df_clean, aes(x=dNBR, y=aET)) +
#   geom_point(alpha=0.3) +
#   geom_point(aes(y=pred_4), col="red", alpha=0.3) +
#   theme_bw() +
#   labs(title="aET vs dNBR", x="dNBR", y="aET")
# 
# # hexbin plots
# library(hexbin)
# 
# ggplot(df_clean, aes(x=dNBR, y=aET)) +
#   geom_hex() +
#   geom_point(aes(y=pred_4), col=pred_color, alpha=0.3) +
#   scale_fill_viridis() +
#   theme_bw() +
#   labs(title="aET vs dNBR", x="dNBR", y="aET")
# 
# # 2D density plot
# ggplot(df_clean, aes(x=dNBR, y=aET)) +
#   geom_density2d() +
#   geom_point(aes(y=pred_4), col=pred_color, alpha=0.3) +
#   theme_bw() +
#   labs(title="aET vs dNBR", x="dNBR", y="aET")

# # faceting
# # create a smaller random sample for faceting
# set.seed(123)
# sample_indices <- sample(1:nrow(df_clean), 10000)
# df_sample <- df_clean[sample_indices,]
# df_sample$group <- cut(df_sample$elev, breaks=4, labels=c("Low", "Medium Low", "Medium High", "High"))
# df_sample$pred_sample <- predict(lm_aET_4, newdata = df_sample)
# 
# ggplot(df_sample, aes(x=dNBR, y=aET)) +
#   geom_point() +
#   geom_point(aes(y=pred_sample), col=pred_color, alpha=0.3) +
#   facet_wrap(~group) +
#   theme_bw() +
#   labs(title="aET (mm/month) vs dNBR by Elevation Group", x="dNBR", y="aET")

```

```{r}
# # Fit the GAM model with shrinkage splines to 
# gam_aET <- mgcv::gam(aET ~ s(temp, bs = "cs", k=20) + s(precip, bs = "cs", k=20) + s(elev, bs = "cs", k=20) +
#                        s(aspect, bs = "cs", k=20) + s(slope, bs = "cs", k=20) + s(soil_moisture, bs = "cs", k=20) +
#                        s(dNDVI, bs = "cs") + s(dNBR, bs = "cs") + s(lon, bs = "cs", k=20) + s(lat, bs = "cs", k=20),
#                      data = df_clean, method = "REML")
# 
# 
# # Save the model to a file
# save(gam_aET, file = "gam_aET_4.RData")
# 
# # Check the summary of the model
# summary(gam_aET)
# 
# par(mfrow=c(2, 2))
# gam.check(gam_aET)
# 
# # Plot the smooth terms
# par(mfrow=c(3,4)) # Adjust layout to fit all plots
# plot(gam_aET, pages=3)
# 
# par(mfrow=c(2, 2))
# gam.check(gam_aET, k.sample = 500000)
# 
# # If you prefer ggplot-style plots, you can use ggplot2 with `gratia` package for better control
# # install.packages("gratia") # Uncomment if not already installed
# library(gratia)
# 
# draw(gam_aET)
# 
# # look at AIC
# AIC(lm_dNDVI, gam_dNDVI)
# 
# # the question is, are there smooth functions that I should totally 
# # penalize out of the model?
# 
# library(mgcv)
# library(parallel)

# bam_aET_adjusted <- mgcv::bam(aET ~ s(temp, bs = "cs", k = 30) + s(precip, bs = "cs", k = 50) + 
#                               s(elev, bs = "cs", k = 60) + s(aspect, bs = "cs", k = 30) + 
#                               s(slope, bs = "cs", k = 30) + s(soil_moisture, bs = "cs", k = 30) +
#                               s(dNDVI, bs = "cs", k = 20) + s(dNBR, bs = "cs", k = 30) + 
#                               s(lon, bs = "cs", k = 40) + s(lat, bs = "cs", k = 50), 
#                               data = df_clean, method = "fREML", nthreads = detectCores() - 1)

bam_aET <- mgcv::bam(aET ~ s(temp) + s(precip) + 
                              s(elev) + s(aspect) +
                              s(slope) + s(soil_moisture) +
                              s(dNDVI) + s(dNBR) +
                              s(lon) + s(lat),
                              data = df_clean, method = "REML", select=TRUE,
                     nthreads = detectCores() - 1)

# Check the summary of the model
summary(bam_aET)

# Check diagnostics
par(mfrow=c(2, 2))
gam.check(bam_aET)

plot(bam_aET)

vis.gam(bam_aET,view=c("lon","lat"))

save(bam_aET, file = "bam_aET.RData")
```

```{r}
# look at fitted values
df_clean$gam_fitted_values <- predict(bam_aET)
df_clean$gam_residuals <- df_clean$aET - df_clean$fitted_values

# Scatter plot of response vs. fitted values
ggplot(df_clean, aes(x=fitted_values, y=aET)) +
  geom_point(alpha=0.5) +
  geom_abline(slope=1, intercept=0, color="red") +
  theme_bw() +
  labs(title="Scatter Plot of Response vs. Fitted Values", x="Fitted Values", y="Response (aET)")

# Residuals vs. Fitted Values
ggplot(df_clean, aes(x=fitted_values, y=residuals)) +
  geom_point(alpha=0.5) +
  geom_hline(yintercept=0, color="red") +
  theme_bw() +
  labs(title="Residuals vs. Fitted Values", x="Fitted Values", y="Residuals")

# QQ Plot of Residuals
ggplot(df_clean, aes(sample=residuals)) +
  stat_qq() +
  stat_qq_line() +
  theme_bw() +
  labs(title="QQ Plot of Residuals", x="Theoretical Quantiles", y="Sample Quantiles")

# Histogram of Residuals
ggplot(df_clean, aes(x=residuals)) +
  geom_histogram(bins=30, fill="blue", alpha=0.7) +
  theme_bw() +
  labs(title="Histogram of Residuals", x="Residuals", y="Frequency")

```

```{r}
stopCluster(cl)
registerDoSEQ()
```

