---
title: "build_models_rET"
author: "Carrie Hashimoto"
date: "2024-07-29"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, warning = FALSE, message = FALSE}
packages <- c('tidyverse','mgcv','akima','readr','data.table','vroom',
              'foreach','doParallel','readr','caret','leaps','parallel','leaps',
              'viridis','combinat','coefplot','car','interactions','ggeffects')

# Identify missing (not installed) packages
new.packages <-  packages[!(packages %in% installed.packages()[,"Package"])]

# Install new (not installed) packages
if(length(new.packages)) install.packages(new.packages, repos='http://cran.rstudio.com/') else print('All required packages are installed.')

invisible(lapply(packages, library, character.only = TRUE))
```

```{r}
wd <- rprojroot::find_rstudio_root_file()
outDir <- file.path(wd, "Models", fsep="/")
suppressWarnings(dir.create(outDir)) 

num_cores <- detectCores() - 1
cl <- makeCluster(num_cores - 1)  # Use one less core than available
registerDoParallel(cl)
```

```{r}
df <- vroom::vroom("model_df_outliers_removed.csv")
names(df)

# ind owhat's going onnnnn -_-
# 
# set.seed(0)  # For reproducibility
# sample_size <- 100000  # Number of random points to sample
# 
# subset_df <- df %>%
#   sample_n(sample_size)
# 
# ggplot(subset_df, aes(x = lon, y = lat)) +
#   geom_point(alpha = 0.5) +
#   theme_minimal() +
#   labs(title = "Random Subset of Longitude and Latitude Points",
#        x = "Longitude", y = "Latitude")
```

```{r}
predictors <- c("lat","lon","prefire_ndvi","prefire_nbr","dndvi","dnbr","rdnbr","temp","precip",
                "elev","slope","aspect", "north","soil_moisture")

lm_rET_formula <- as.formula(paste("rET ~", paste(predictors, collapse = " + ")))
```

```{r}
# start with a basic MLR model
lm_rET <- lm(lm_rET_formula, data = df)

summary.lm_rET <- summary(lm_rET)
  print(summary.lm_rET)

# load(paste0(outDir, "/lm_rET.RData"))

save(lm_rET, file = paste0(outDir, "/lm_rET.RData"))
```


```{r}
# generate two-way interactions
two_way_interactions <- combn(predictors, 2, function(x) paste(x, collapse = ":"))

# all terms == huge ass model
all_terms <- c(predictors,two_way_interactions)

# create the formula
interaction_formula <- as.formula(paste("rET ~", paste(all_terms, collapse = " + ")))

```

```{r}
# make a huge interaction model
lm_rET_interaction <- lm(interaction_formula, data = df)

summary.lm_rET_interaction <- summary(lm_rET_interaction)
print(summary.lm_rET_interaction)

save(lm_rET_interaction, file = paste0(outDir,"/lm_rET_interaction.RData"))
```


```{r}
library(leaps)

# set up function to combine CV and best subset selection
set.seed(0)

k <- 10
n <- nrow(df)

folds <- sample(rep(1:k, length = n))

cv.errors <- matrix(NA, k, 10, dimnames = list(NULL, paste(1:10)))

# Define a prediction function for regsubsets models
predict.regsubsets <- function(object, newdata, id) {
  # Extract the formula from the regsubsets object
  formula <- as.formula(object$call[[2]])
  mat <- model.matrix(formula, newdata)
  coefi <- coef(object, id = id)
  xvars <- names(coefi)
  mat[, xvars, drop = FALSE] %*% coefi
}
```

```{r}
library(scales)
```

```{r}
# Cross-validation loop
for (j in 1:k) {
  train_data <- df[folds != j, ]
  test_data <- df[folds == j, ]
  
  # Fit the regsubsets model on the training data
  best.fit <- regsubsets(as.formula(interaction_formula), data = train_data, nvmax = 10, method="forward")
  
  for (i in 1:10) {
    pred <- predict.regsubsets(best.fit, newdata = test_data, id = i)
    cv.errors[j, i] <- mean((test_data$aET - pred)^2)
  }
}

# Calculate average CV error for each model size
mean_cv_errors <- apply(cv.errors, 2, mean)
mean_cv_errors <- data.frame(num_predictors=seq(1,10),mean_cv_errors=mean_cv_errors)
library(viridis)
viridis_colors <- viridis(6, option = "viridis")

# plot that shit
lm_rET_cv_plot <- ggplot(mean_cv_errors, aes(x=num_predictors, y=mean_cv_errors, col="forward selection")) +
  geom_point(col="black") +
  labs(title="Cross-validation error for MLRs \n using forward selection of predictors",
       x="Number of predictors", y="Mean cross-validation error",
        text = element_text(size = 24),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_x_continuous(breaks= pretty_breaks()) +
  guides(fill = guide_legend(title = "Cross-validation error"))

fwrite(mean_cv_errors,paste0(wd,"/Figures/lm_rET_cv_plot.png"))

ggsave(paste0(wd,"/Figures/lm_rET_cv_plot.png"), lm_rET_cv_plot, width = 5, 
       height = 3, units = "in")

# best model size according to this
best_model_size <- which.min(mean_cv_errors$mean_cv_errors)

```

```{r}

# now do best subset selection once
lm_rET_best_subset <- regsubsets(interaction_formula,
           data=df, nvmax = 3, really.big=TRUE)

lm_rET_best_subset.summary <- summary(lm_rET_best_subset)

print(lm_rET_best_subset.summary)

final_coefs <- coef(lm_rET_best_subset, id = best_model_size) # best model size
lm_rET_interaction_reduced_predictors <- names(final_coefs)[-1] # omit the intercept

 #  (Intercept)           lat    dndvi:elev  rdnbr:precip 
 # 1.097504e+03 -2.937426e+01  3.138532e-02  4.301111e-03 
```

```{r}
# final model
lm_rET_interaction_reduced_formula <- as.formula(paste("rET ~", paste(lm_rET_interaction_reduced_predictors, collapse = " + ")))

lm_rET_interaction_reduced <- lm(lm_rET_interaction_reduced_formula, data=df)

lm_rET_interaction_reduced.summary <- summary(lm_rET_interaction_reduced)
print(lm_rET_interaction_reduced.summary)

save(lm_rET_interaction_reduced, file = paste0(outDir, "/lm_rET_interaction_reduced.RData"))
```

Try lasso if time:
```{r}
# library(glmnet)
# 
# # prep data
# response <- df$rET
# predictors <- model.matrix(interaction_formula, data = df)[,-1]
# 
# # # standardize predictors... 10000 deaths
# # predictors <- scale(predictors)
# 
# # Cross-validation to find the best lambda
# set.seed(0)
# lasso_rET_cv <- cv.glmnet(predictors, response, alpha = 1, nfolds = 10)  # alpha = 1 for Lasso, 0 for Ridge
# ridge_rET_cv <- cv.glmnet(predictors, response, alpha = 0, nfolds = 10)
# 
# # Get the best lambda
# lasso_rET_best_lambda <- lasso_rET_cv$lambda.min
# ridge_rET_best_lambda <- ridge_rET_cv$lambda.min
# 
# # Fit the final model with the best lambda
# lasso_rET_final <- glmnet(predictors, response, alpha = 1, lambda = lasso_rET_best_lambda)
# ridge_rET_final <- glmnet(predictors, response, alpha = 0, lambda = ridge_rET_best_lambda)
# 
# # Print the coefficients of the final model
# print(coef(lasso_rET_final))
# print(coef(ridge_rET_final))
# 
# # Plot the cross-validation results
# plot(lasso_rET_cv)
# plot(ridge_rET_cv)
# 
# save(lasso_rET_final, file=paste0(outDir,"/lasso_rET_final.rds"))
# save(ridge_rET_final, file=paste0(outDir,"/ridge_rET_final.rds"))
```


```{r}
stopCluster(cl)
registerDoSEQ()
```

```{r}
library(ggpubr)
load(paste0(wd,"/Models/lm_rET_interaction.RData"))

plot(lm_rET_interaction)
summary(lm_rET_interaction)

residuals <- residuals(lm_rET_interaction)
fitted_values <- fitted(lm_rET_interaction)

# Combine the residuals and fitted values into a dataframe
residuals_df <- data.frame(fitted_values = fitted_values, residuals = residuals)

# Take a sample of the data (e.g., 1000 points)
set.seed(0) # For reproducibility
sampled_residuals_df <- residuals_df[sample(nrow(residuals_df), 10000), ]

# QQ Plot with viridis color scheme
qq_plot <- ggqqplot(residuals_df$residuals, title = "QQ Plot of Residuals") +
  theme_bw() +
  scale_color_viridis()

# Residuals Plot with viridis color scheme
residuals_plot <- ggplot(residuals_df, aes(x = fitted_values, y = residuals)) +
  geom_point() +
  geom_line(aes(y=0),size = 1) + # Optional: Add a smooth line
  labs(
    title = "Residuals vs Fitted Values",
    x = "Fitted Values",
    y = "Residuals"
  ) +
  theme_bw()

# Arrange the plots next to each other
combined_plot <- ggarrange(qq_plot, residuals_plot, ncol = 2, nrow = 1)

ggsave(paste0(wd,"/Figures/lm_rET_interaction_plot.png"), combined_plot, width = 6, 
       height = 3, units = "in")

```

```{r}
lm_rET_interaction_reduced2_formula <- rET ~ lat + lon + 
  prefire_ndvi + dnbr + soil_moisture +
  temp + precip + elev + north + dnbr:prefire_ndvi + temp:elev

# Fit the model using bam
lm_rET_interaction_reduced2 <- lm(lm_rET_interaction_reduced2_formula,
                     data = df)

lm_rET_interaction_reduced2.summary <- summary(lm_rET_interaction_reduced2)

# print results
print(lm_rET_interaction_reduced2.summary)

# look at smooths
save(lm_rET_interaction_reduced2, file = paste0(outDir, "/lm_rET_interaction_reduced2.RData"))
```



```{r}
library(ggpubr)
load(paste0(wd,"/Models/bam_rET_interaction_big.RData"))

summary(bam_rET_interaction_big)

residuals <- residuals(bam_rET_interaction_big)
fitted_values <- fitted(bam_rET_interaction_big)

# Combine the residuals and fitted values into a dataframe
residuals_df <- data.frame(fitted_values = fitted_values, residuals = residuals)

# Take a sample of the data (e.g., 1000 points)
set.seed(0) # For reproducibility
sampled_residuals_df <- residuals_df[sample(nrow(residuals_df), 10000), ]

# QQ Plot with viridis color scheme
qq_plot <- ggqqplot(residuals_df$residuals, title = "QQ Plot of Residuals",col=viridis(6)[3]) +
  geom_abline(slope = 1, intercept = 0, size = 1) +
  theme_bw() +
  scale_color_viridis()

# Residuals Plot with viridis color scheme
residuals_plot <- ggplot(residuals_df, aes(x = fitted_values, y = residuals)) +
  geom_point(col= viridis(6)[3]) +
  geom_line(aes(y=0),size = 1) + # Optional: Add a smooth line
  labs(
    title = "Residuals vs Fitted Values",
    x = "Fitted Values",
    y = "Residuals"
  ) +
  theme_bw()

# Arrange the plots next to each other
combined_plot <- ggarrange(qq_plot, residuals_plot, ncol = 2, nrow = 1)

ggsave(paste0(wd,"/Figures/lm_rET_interaction_plot.png"), combined_plot, width = 8, 
       height = 5, units = "in")

```

```{r}
load(paste0(wd,"/Models/bam_rET_interaction_reduced.RData"))

summary(bam_rET_interaction_reduced)
summary(bam_rET_interaction_big)
```



