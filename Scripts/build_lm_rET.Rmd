---
title: "build_models_rET"
author: "Carrie Hashimoto"
date: "2024-07-29"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, warning = FALSE, message = FALSE}
packages <- c('tidyverse','mgcv','akima','readr','data.table','vroom',
              'foreach','doParallel','readr','caret','leaps','parallel','leaps',
              'viridis','combinat','coefplot','car','interactions','ggeffects')

# Identify missing (not installed) packages
new.packages <-  packages[!(packages %in% installed.packages()[,"Package"])]

# Install new (not installed) packages
if(length(new.packages)) install.packages(new.packages, repos='http://cran.rstudio.com/') else print('All required packages are installed.')

invisible(lapply(packages, library, character.only = TRUE))
```

```{r}
wd <- rprojroot::find_rstudio_root_file()
outDir <- file.path(wd, "Models", fsep="/")
suppressWarnings(dir.create(outDir)) 

num_cores <- detectCores() - 1
cl <- makeCluster(num_cores - 1)  # Use one less core than available
registerDoParallel(cl)
```

```{r}
df <- vroom::vroom("model_df_outliers_removed.csv")
```

```{r}
predictors <- c("lat","lon","prefire_ndvi","dndvi","dnbr","temp","precip",
                "elev","aspect","slope","north","soil_moisture")

base_formula <- as.formula(paste("rET ~", paste(predictors, collapse = " + ")))
```

```{r}
# start with a basic MLR model
lm_rET <- lm(base_formula, data = df)

summary.lm_rET <- summary(lm_rET)
summary.lm_rET 

save(lm_rET, file = paste0(outDir, "/lm_rET.RData"))
```


```{r}
# generate two-way interactions
two_way_interactions <- combn(predictors, 2, function(x) paste(x, collapse = ":"))

# all terms == huge ass model
all_terms <- c(predictors,two_way_interactions)

# create the formula
interaction_formula <- as.formula(paste("rET ~", paste(all_terms, collapse = " + ")))

```

```{r}
# make a huge interaction model
lm_rET_interaction <- lm(interaction_formula, data = df)

summary.lm_rET_interaction <- summary(lm_rET_interaction)
summary.lm_rET_interaction

save(lm_rET_interaction, file = paste0(outDir,"/lm_rET_interaction.RData"))

# some of these aren't helpful; do model selection
```




```{r}
library(leaps)

# set up function to combine CV and best subset selection
set.seed(0)

k <- 10
n <- nrow(df)

folds <- sample(rep(1:k, length = n))

cv.errors <- matrix(NA, k, 10, dimnames = list(NULL, paste(1:10)))

# Define a prediction function for regsubsets models
predict.regsubsets <- function(object, newdata, id) {
  # Extract the formula from the regsubsets object
  formula <- as.formula(object$call[[2]])
  mat <- model.matrix(formula, newdata)
  coefi <- coef(object, id = id)
  xvars <- names(coefi)
  mat[, xvars, drop = FALSE] %*% coefi
}
```


```{r}
# Cross-validation loop
for (j in 1:k) {
  train_data <- df[folds != j, ]
  test_data <- df[folds == j, ]
  
  # Fit the regsubsets model on the training data
  best.fit <- regsubsets(as.formula(interaction_formula), data = train_data, nvmax = 10, method="forward")
  
  for (i in 1:10) {
    pred <- predict.regsubsets(best.fit, newdata = test_data, id = i)
    cv.errors[j, i] <- mean((test_data$aET - pred)^2)
  }
}

# Calculate average CV error for each model size
mean_cv_errors <- apply(cv.errors, 2, mean)

# plot that shit
plot(mean_cv_errors, type="b")
# wow, for real??

# best model size according to this
best_model_size <- which.min(mean_cv_errors)

```



```{r}
# welp
# now do best subset selection once
lm_rET_best_subset <- regsubsets(interaction_formula,
           data=df, nvmax = 10, method="forward")

lm_rET_best_subset.summary <- summary(lm_rET_best_subset)

lm_rET_best_subset.summary

final_coefs <- coef(lm_rET_best_subset, id = best_model_size) # best model size
lm_rET_interaction_reduced_predictors <- names(final_coefs)[-1] # omit the intercept


```

```{r}
# final model
lm_rET_interaction_reduced_formula <- as.formula(paste("rET ~", paste(lm_rET_interaction_reduced_predictors, collapse = " + ")))

lm_rET_interaction_reduced <- lm(rET ~ dnbr + lat + precip + prefire_ndvi:dnbr + elev:dnbr +
                     lat:dnbr + lat:precip, data=df)

lm_rET_interaction_reduced.summary <- summary(lm_rET_interaction_reduced)
lm_rET_interaction_reduced.summary

save(lm_rET_interaction_reduced, file = paste0(outDir, "/lm_rET_interaction_reduced.RData"))
```

Try lasso if time:
```{r}
# library(glmnet)
# 
# # prep data
# response <- df$rET
# predictors <- model.matrix(interaction_formula, data = df)[,-1]
# 
# # # standardize predictors... 10000 deaths
# # predictors <- scale(predictors)
# 
# # Cross-validation to find the best lambda
# set.seed(0)
# lasso_rET_cv <- cv.glmnet(predictors, response, alpha = 1, nfolds = 10)  # alpha = 1 for Lasso, 0 for Ridge
# ridge_rET_cv <- cv.glmnet(predictors, response, alpha = 0, nfolds = 10)
# 
# # Get the best lambda
# lasso_rET_best_lambda <- lasso_rET_cv$lambda.min
# ridge_rET_best_lambda <- ridge_rET_cv$lambda.min
# 
# # Fit the final model with the best lambda
# lasso_rET_final <- glmnet(predictors, response, alpha = 1, lambda = lasso_rET_best_lambda)
# ridge_rET_final <- glmnet(predictors, response, alpha = 0, lambda = ridge_rET_best_lambda)
# 
# # Print the coefficients of the final model
# print(coef(lasso_rET_final))
# print(coef(ridge_rET_final))
# 
# # Plot the cross-validation results
# plot(lasso_rET_cv)
# plot(ridge_rET_cv)
# 
# save(lasso_rET_final, file=paste0(outDir,"/lasso_rET_final.rds"))
# save(ridge_rET_final, file=paste0(outDir,"/ridge_rET_final.rds"))
```


```{r}
stopCluster(cl)
registerDoSEQ()
```

