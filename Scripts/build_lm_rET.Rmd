---
title: "build_models_rET"
author: "Carrie Hashimoto"
date: "2024-07-29"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, warning = FALSE, message = FALSE}

# elev, precip, temp
# elev, dNBR

packages <- c('tidyverse','mgcv','akima','readr','data.table','vroom',
              'foreach','doParallel','readr','caret','leaps','parallel','leaps',
              'viridis','combinat','coefplot','car','interactions','ggeffects')

# Identify missing (not installed) packages
new.packages <-  packages[!(packages %in% installed.packages()[,"Package"])]

# Install new (not installed) packages
if(length(new.packages)) install.packages(new.packages, repos='http://cran.rstudio.com/') else print('All required packages are installed.')

invisible(lapply(packages, library, character.only = TRUE))
```

```{r}
wd <- rprojroot::find_rstudio_root_file()
outDir <- file.path(wd, "Data", fsep="/")
suppressWarnings(dir.create(outDir)) 

num_cores <- detectCores() - 1
cl <- makeCluster(num_cores - 1)  # Use one less core than available
registerDoParallel(cl)
```

```{r}
df_final <- vroom::vroom("intermediate_results.csv")
df_final$rET <- df_final$aET / df_final$prefire_ET * 100

# remove rows with NAs
df_clean <- na.omit(df_final)
```

```{r}
# define interaction terms
# lat + lon + dNDVI + dNBR + temp + precip + elev + aspect + slope + soil_moisture
predictors <- list("lat", "lon", "dNDVI", "dNBR", "temp",
                   "precip","elev","aspect","slope","soil_moisture")

# Generate two-way interactions
two_way_interactions <- combn(predictors[4:10], 2, function(x) paste(x, collapse = ":"))

# Print two-way interactions
two_way_interactions

# Only grab the ones of interest... otherwise it would take too long :(
all_terms <- c(predictors,"dNBR:temp","dNBR:precip","dNBR:elev","dNBR:aspect",
               "dNBR:soil_moisture","temp:precip","temp:elev",
               "temp:aspect","temp:slope","temp:soil_moisture","precip:elev",
               "precip:aspect","precip:slope","precip:soil_moisture","elev:aspect",
               "elev:slope","elev:soil_moisture","aspect:slope")

# Create the formula
interaction_formula <- as.formula(paste("rET ~", paste(all_terms, collapse = " + ")))

# Print the formula
interaction_formula
```

```{r}
set.seed(0)

k <- 10
n <- nrow(df_clean)

folds <- sample(rep(1:k, length = n))

cv.errors <- matrix(NA, k, 10,
                    dimnames = list(NULL, paste(1:10)))

# define a prediction function
predict.regsubsets <- function(object, newdata, id, ...) {
  form <- as.formula(object$call [[2]])
  mat <- model.matrix(form, newdata)
  coefi <- coef(object, id = id)
  xvars <- names(coefi)
  mat[, xvars] %*% coefi
  }

for (j in 1:k) {
  best.fit <- regsubsets(rET ~ lat + lon + dNDVI + dNBR + temp + precip + 
                           elev + aspect +  slope + soil_moisture + dNBR:temp + 
                           dNBR:precip + dNBR:elev + dNBR:aspect + 
                           dNBR:soil_moisture + temp:precip + temp:elev + 
                           temp:aspect + temp:slope + temp:soil_moisture + 
                           precip:elev + precip:aspect + precip:slope + 
                           precip:soil_moisture + elev:aspect + 
                           elev:slope + elev:soil_moisture + aspect:slope,
                         data = df_clean[folds != j, ],
                         nvmax = 10)
  for (i in 1:10) {
    pred <- predict(best.fit, df_clean[folds == j, ], id = i)
    cv.errors[j, i] <- 
      mean((df_clean$aET[folds == j] - pred)^2)
  }
}
```

```{r}
# result: 10x10 matrix where [j,i]th element is test MSE for the jth CV fold for the best i-variable model
cv.errors

mean.cv.errors <- apply(cv.errors, 2, mean)
mean.cv.errors

# plot that shit
par(mfrow = c(1,1))
plot(mean.cv.errors, type="b")
```

```{r}
# welp
# look at it for all data, I guess...

regfit.full <- regsubsets(rET ~ lat + lon + dNDVI + dNBR + temp + precip + 
                           elev + aspect +  slope + soil_moisture + dNBR:temp + 
                           dNBR:precip + dNBR:elev + dNBR:aspect + 
                           dNBR:soil_moisture + temp:precip + temp:elev + 
                           temp:aspect + temp:slope + temp:soil_moisture + 
                           precip:elev + precip:aspect + precip:slope + 
                           precip:soil_moisture + elev:aspect + 
                           elev:slope + elev:soil_moisture + aspect:slope,
           data=df_clean, nvmax = 28)

reg.summary <- summary(regfit.full)

reg.summary
# looks like dNBR is the best predictor
# dNBR and soil moisture and elev are good together
```

```{r}
# Assuming reg.summary is your dataframe
# Create a dataframe for plotting
df <- data.frame(
  num_vars = seq_along(reg.summary$rss),
  rss = reg.summary$rss,
  adjr2 = reg.summary$adjr2,
  cp = reg.summary$cp,
  bic = reg.summary$bic
)

highlight_color <- viridis(1, begin = 0.8, end = 1, option="inferno")[1]

# Plot RSS
ggplot(df, aes(x = num_vars, y = rss)) +
  geom_line(color = viridis(1)) +
  labs(x = "Number of Variables", y = "RSS") +
  theme_minimal()

# Plot Adjusted R^2
ggplot(df, aes(x = num_vars, y = adjr2)) +
  geom_line(color = viridis(1)) +
  geom_point(aes(x = which.max(df$adjr2), y = df$adjr2[which.max(df$adjr2)]), color = highlight_color, size = 3) +
  labs(x = "Number of Variables", y = "Adjusted R^2") +
  theme_minimal()

# Plot Cp
ggplot(df, aes(x = num_vars, y = cp)) +
  geom_line(color = viridis(1)) +
  geom_point(aes(x = which.min(df$cp), y = df$cp[which.min(df$cp)]), color = highlight_color, size = 3) +
  labs(x = "Number of Variables", y = "Cp") +
  theme_minimal()

# Plot BIC
ggplot(df, aes(x = num_vars, y = bic)) +
  geom_line(color = viridis(1)) +
  geom_point(aes(x = which.min(df$bic), y = df$bic[which.min(df$bic)]), color = highlight_color, size = 3) +
  labs(x = "Number of Variables", y = "BIC") +
  theme_minimal()

```

```{r}

# take a look at the model I like the best
names(coef(regfit.full, 16))

# make the 4-variable model and look at the results
lm_rET_16 <- lm(rET ~ lat + lon + dNBR + temp+aspect + soil_moisture + 
                  dNBR:temp + dNBR:elev + temp:precip + 
                  temp:elev + temp:aspect + temp:slope + 
                  precip:elev + precip:slope + precip:soil_moisture + 
                  elev:aspect, data = model_df)

# Save the model to a file
save(lm_rET_16, file = "lm_rET_16.RData")

summary(lm_rET_16)

par(mfrow = c(2, 2))
plot(lm_rET_16)



```

```{r}
# generate plots for results interpretation
summary(lm_rET_16)

# Residuals vs Fitted Values
plot(lm_rET_16, which = 1)

# Normal Q-Q Plot
plot(lm_rET_16, which = 2)

# Scale-Location Plot
plot(lm_rET_16, which = 3)

# Residuals vs Leverage Plot
plot(lm_rET_16, which = 5)

# Coefficient Plot
coefplot(lm_rET_16)

# Partial Regression Plots
avPlots(lm_rET_16)

# Interaction Effects Plot
interaction_plot <- interact_plot(lm_rET_16, pred = temp, modx = precip)
print(interaction_plot)

# Marginal Effects Plot (example)
marginal_effects <- ggpredict(lm_rET_16, terms = "elev")
plot(marginal_effects)

# Predicted vs Actual Plot
predicted_values <- predict(lm_rET_16, df_clean)
ggplot(data = df_clean, aes(x = predicted_values, y = aET)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  labs(x = "Predicted Values", y = "Actual Values") +
  theme_minimal()

```


```{r}
stopCluster(cl)
registerDoSEQ()
```

